Алгоритм, задание 8

тест

nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6

Эти инструкции выполняются в следующем порядке:

nop +0  | 1
acc +1  | 2, 8(!)
jmp +4  | 3
acc +3  | 6
jmp -3  | 7
acc -99 |
acc +1  | 4
jmp -4  | 5
acc +6  |

операции ( acc, jmp или nop)
аргумента (числа со знаком, например +4или -20)



Сохранить строки в объекты (Инструкции) "nop +0"
Индекс строки будет ключом в map для каждого объекта, его же id.
Обеспечит последовательную нумерацию объектов.
Использовать булевый флаг, обоозначающий  двойное применение оператора
Объекты сохранить в коллекцию map.

Часть 1

accumulator подсчитывает значения.
step возможно аналог id оъекта
? возможно лучше пройтись по объектам и запускать метод внутри них, получая обратно значение accumulator

Функция:
при каждом прохождении через операцию делать заметку(логическую false) о том,
что она была. Для учета повтора.
Знать количество объектов, для учета выхода за их количество,
учесть -1, тк считается не как индекс с 0, а с 1 как обычный счет.

Если "nop" то появление(повторение)
начать след строку.

Если "acc" то появление(повторение)
сохранить в accumulator число из объекта

Если "jmp" то изменить currentId

    Если currentId не выходит за пределы массива (т.е. он равен одному из id)
    прибавить к currentId значение из объекта.

    Иначе
    формула : step = abs((-currentObj.getId()) + (argumentObj % COUNT_INSTRACTION));
    модуль числа( ((-1) * id текущего объекта)
    + (остаток от деления аргумента(поле у объекта)на количество объектов в map)

    Логика:
    (argumentObj % COUNT_INSTRACTION) - удалить все избыточное вхождение числа в количество элементов
      id объекта сделать отрицательным, что обеспечит движеение вверх по списку или сниз, зависимо от аргумента в объекте




Ответ 1797

Часть 2




























